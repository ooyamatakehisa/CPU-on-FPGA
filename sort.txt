1:LI R7 64
LI R6 64
SLL R7 4 //R7=1024
Sll R6 5 //R6=2048

5:CMP R7 R6
BE 6
LD R0 0(R7)
ADDI R7 1
LD R1 0(R7)
COM R1 R0
BLT 12
B -8

移設作業
13:SLL R7 1
CMP R6 R7
BE 7
LD R0 0(R7)
LD R1 1(R7)
ST R0 0(R5)
ST R1 1(R5)
ADDI R7 2
ADDI R5 2
B -9
HLT


メモリからバケツに取り出す準備
24:LI R0 64  //R0=64=2^6
LI R1 64
LI R5 64
SLL R1 5   //R1=2048=2^11
SRL R7 1   //R7=1024: ソートする値をメモリからロードするときのアドレスを指定するレジスタR7
SLL R5 4   //R5=1024: バケツ1用のアドレスを格納するレジスタR5
SRL R6 2  //R6=2^6: 各桁だけを取り出すための0000_0000_0000_0001てきなやつ11桁目から上をソート

MOV R3 R5  //R3=1024

＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿＿
32:CMP R7 R1  //R7が2048=2^11になったらZフラグ
BE 16      //R7=2048なら分岐、R7!=2048ならそのまま

最初にメモリから値を取り出してバケツに振り分け
34:LD R0 0(R7) //R0=m[R7]: R7に格納されているアドレスのメモリ内容（ソートする対象）をR0に格納
AND R0 R6   //R0=R0&R6: ソートする対象のR6で設定された取り出すべきbitだけを取り出しR0に格納
CMPI R0 0   //対象桁(bit)が0かどうか判断
BE 6        //その桁が0ならその値を0のバケツにロードするコードに分岐、違うなら(1なら)その値を1のバケツにロードするそのまま

38:LD R0 0(R7) //もう一度振り分ける値をレジスタに読み込み
ADDI R3 1   //R3=R3+1:バケツ1の最後のアドレスを示すR3の値+1
ADDI R7 1   //R7=R7+1: R7を次のアドレスに更新(+1)
ST R0 0(R5) //見た桁(bit)が1のとき調べた値R0を1のバケツに格納
ADDI R5 1   //バケツ1用のアドレスR5を次のアドレスに更新(+1)
//B -12    //R3は関係なし、PC=10のところにジャンプ

44:LD R0 0(R7) //もう一度振り分ける値をレジスタに読み込み
ADDI R2 1   //R2=R2+1: バケツ0の要素数を示すR2の値+1
ADDI R7 1   //R7=R7+1: R7を次のアドレスに更新(+1)
ST R0 0(R4) //見た桁(bit)が0のとき調べた値R0を0のバケツに格納
26:ADDI R4 1   //バケツ0用のアドレスR4を次のアドレスに更新(+1)
//B -18    //R3は関係なし、PC=10のところにジャンプ

================================================================================================================

バケツから取り出し振り分け準備とバケツ0から取り出す準備
50:MOV R5 R1  //R5=2048

LI R4 0     //0バケツ用の書き込みアドレスを0に戻す
LI R7 0     //R7=0: R7の値をバケツから値を取り出す用に更新
SLL R6 1    //R6=R6<<1: 各桁だけを取り出すための0000_0000_0000_0001てきなやつの取り出す位置を更新

_______________________________________________________________________________________________________
*
0用バケツの取り出し終わり判定
32:CMP R7 R2  //R7のアドレスとバケツ0の要素数と比較
BE 14       //もし上の条件が成り立てばバケツ1の取り出しへ、もし違うならR0のバケツの取り出しを続けるそのまま

バケツから取り出してバケツに振り分け(0)
34:LD R0 0(R7) //R0=m[R7]: R7に格納されているアドレスのメモリ内容（ソートする対象）をR0に格納
AND R0 R6   //R0=R0&R6: ソートする対象のR6で設定された取り出すべきbitだけを取り出しR0に格納
CMPI R0 0   //対象桁(bit)が0かどうか判断
BE 5        //PC=PC+1+3: その桁が0ならその値を0のバケツにロードするコードに分岐、違うなら(1なら)その値を1のバケツにロードするそのまま

38:LD R0 0(R7) //もう一度振り分ける値をレジスタに読み込み
ADDI R7 1   //R7=R7+1: R7を次のアドレスに更新(+1)
ST R0 0(R5) //見た桁(bit)が1のとき調べた値R0を1のバケツに格納
ADDI R5 1   //バケツ1用のアドレスR5を次のアドレスに更新(+1)
B -11       //R3は関係なし、PC=PC-12のところにジャンプ

43:LD R0 0(R7) //もう一度振り分ける値をレジスタに読み込み
ADDI R7 1   //R7=R7+1: R7を次のアドレスに更新(+1)
ST R0 0(R4) //見た桁(bit)が0のとき調べた値R0を0のバケツに格納
ADDI R4 1   //バケツ0用のアドレスR4を次のアドレスに更新(+1)
B -16       //R3は関係なし、PC=PC-18のところにジャンプ

*_______________________________________________________________________________________________

バケツ1から取り出すための準備
48:MOV R7 R1   //R7=2048
CMP R5 R1   //バケツ1の取り出し先の比較
BLT 1       //もし前の振り分けで1024~に格納したら分岐、そうでない2048~ならそのまま
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  バケツ1の取り出し先が1024~、
  SRL R7 1  //R7=1024
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  バケツ1の取り出し先が2048~

__________________________________________________________________________________________
*
1用バケツの取り出し終わり判定
52: CMP R7 R3  //R7のアドレスとバケツ1の要素数と比較
BE 14      //もし上の条件が成り立てば次のbitの振り分けの準備へ

バケツから取り出してバケツに振り分け(0)
54:LD R0 0(R7) //R0=m[R7]: R7に格納されているアドレスのメモリ内容（ソートする対象）をR0に格納
AND R0 R6   //R0=R0&R6: ソートする対象のR6で設定された取り出すべきbitだけを取り出しR0に格納
CMPI R0 0   //対象桁(bit)が0かどうか判断
BE 5        //PC=PC+1+5: その桁が0ならその値を0のバケツにロードするコードに分岐、違うなら(1なら)その値を1のバケツにロードするそのまま

58:LD R0 0(R7) //もう一度振り分ける値をレジスタに読み込み
ADDI R7 1   //R7=R7+1: R7を次のアドレスに更新(+1)
ST R0 0(R5) //見た桁(bit)が1のとき調べた値R0を1のバケツに格納
ADDI R5 1   //バケツ1用のアドレスR5を次のアドレスに更新(+1)
B -11       //R3は関係なし、PC=PC-12のところにジャンプ

63:LD R0 0(R7) //もう一度振り分ける値をレジスタに読み込み
ADDI R7 1   //R7=R7+1: R7を次のアドレスに更新(+1)
ST R0 0(R4) //見た桁(bit)が0のとき調べた値R0を0のバケツに格納
ADDI R4 1   //バケツ0用のアドレスR4を次のアドレスに更新(+1)
B -16       //R3は関係なし、PC=PC-18のところにジャンプ

*____________________________________________________________________________________

次のbitへ移動する準備
68:MOV R3 R5   //R3にバケツ1の最後のアドレスを格納
MOV R2 R4   //バケツ4のアドレス(要素数)R4をR2に格納
MOV R7 R1   //R7=R1=2048=2^11: 基数ソート終わり判定用のR7
SLL R7 3    //R7=2^14=R7=0100_0000_0000_0000

72:CMP R5 R1
BLT 3       //もしR5<2048(前の振り分けで1024~に振り分けていたなら）分岐、そうでないならそのまま
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  バケツ1を2048~に格納したときの要素数の計算
  74:MOV R5 R1 //R5=2048
  SRL R5 1    //R5=1024
  B 1
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  77:MOV R5 R1   //R5=2048

78:CMP R7 R6   //どのビットを振り分けるかようのR6とR7=0100_0000_0000_0000を比べる
BE 1        //もしそこまで行ったら最終bit判定へ
B -52
__________________________________________________________________________________
最終bit(16bit)の振り分けの準備
81:MOV R4 R5
LI R5 0
LI R7 0     //R7=0: R7の値をバケツから値を取り出す用に更新
SLL R6 1    //R6=R6<<1: 各桁だけを取り出すための0000_0000_0000_0001てきなやつの取り出す位置を更新

_______________________________________________________________________________________________________
*最終bit
0用バケツの取り出し終わり判定
85:CMP R7 R2  //R7のアドレスとバケツ0の要素数と比較
BE 14       //もし上の条件が成り立てばバケツ1の取り出しへ、もし違うならR0のバケツの取り出しを続けるそのまま

バケツから取り出してバケツに振り分け(0)
87:LD R0 0(R7) //R0=m[R7]: R7に格納されているアドレスのメモリ内容（ソートする対象）をR0に格納
AND R0 R6   //R0=R0&R6: ソートする対象のR6で設定された取り出すべきbitだけを取り出しR0に格納
CMPI R0 0   //対象桁(bit)が0かどうか判断
BE 5        //PC=PC+1+3: その桁が0ならその値を0のバケツにロードするコードに分岐、違うなら(1なら)その値を1のバケツにロードするそのまま

91:LD R0 0(R7) //もう一度振り分ける値をレジスタに読み込み
ADDI R7 1   //R7=R7+1: R7を次のアドレスに更新(+1)
ST R0 0(R5) //見た桁(bit)が1のとき調べた値R0を1のバケツに格納
ADDI R5 1   //バケツ1用のアドレスR5を次のアドレスに更新(+1)
B -11       //R3は関係なし、PC=PC-12のところにジャンプ

96:LD R0 0(R7) //もう一度振り分ける値をレジスタに読み込み
ADDI R7 1   //R7=R7+1: R7を次のアドレスに更新(+1)
ST R0 0(R4) //見た桁(bit)が0のとき調べた値R0を0のバケツに格納
ADDI R4 1   //バケツ0用のアドレスR4を次のアドレスに更新(+1)
B -16       //R3は関係なし、PC=PC-18のところにジャンプ

*_______________________________________________________________________________________________

バケツ1から取り出すための準備
101:MOV R7 R1   //R7=2048
CMP R4 R1   //バケツ1の取り出し先の比較
BLT 1       //もし前の振り分けで1024~に格納したら分岐、そうでない2048~ならそのまま
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  バケツ1の取り出し先が1024~、
  SRL R7 1  //R7=1024
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  バケツ1の取り出し先が2048~

__________________________________________________________________________________________
*
1用バケツの取り出し終わり判定
105: CMP R7 R3  //R7のアドレスとバケツ1の要素数と比較
BE 14      //もし上の条件が成り立てば次のbitの振り分けの準備へ

バケツから取り出してバケツに振り分け(0)
107:LD R0 0(R7) //R0=m[R7]: R7に格納されているアドレスのメモリ内容（ソートする対象）をR0に格納
AND R0 R6   //R0=R0&R6: ソートする対象のR6で設定された取り出すべきbitだけを取り出しR0に格納
CMPI R0 0   //対象桁(bit)が0かどうか判断
BE 5        //PC=PC+1+5: その桁が0ならその値を0のバケツにロードするコードに分岐、違うなら(1なら)その値を1のバケツにロードするそのまま

111:LD R0 0(R7) //もう一度振り分ける値をレジスタに読み込み
ADDI R7 1   //R7=R7+1: R7を次のアドレスに更新(+1)
ST R0 0(R5) //見た桁(bit)が1のとき調べた値R0を1のバケツに格納
ADDI R5 1   //バケツ1用のアドレスR5を次のアドレスに更新(+1)
B -11       //R3は関係なし、PC=PC-12のところにジャンプ

116:LD R0 0(R7) //もう一度振り分ける値をレジスタに読み込み
ADDI R7 1   //R7=R7+1: R7を次のアドレスに更新(+1)
ST R0 0(R4) //見た桁(bit)が0のとき調べた値R0を0のバケツに格納
ADDI R4 1   //バケツ0用のアドレスR4を次のアドレスに更新(+1)
B -16       //R3は関係なし、PC=PC-18のところにジャンプ
==========================================================================================================

挿入ソートに移るために二つのバケットを連結
121:MOV R7 R1   //R7=2048
CMP R1 R4   //バケツ1の取り出し先の比較
BLT 1       //もし前の振り分けで1024~に格納したら分岐、そうでない2048~ならそのまま
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  バケツ1の取り出し先が1024~、
  SRL R7 1  //R7=1024
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  バケツ1の取り出し先が2048~


125:SRL R1 1
_____________________________________________________
*
126:LD R0 0(R7)
ADDI R7 1
ST R0 0(R5)
ADDI R5 1
CMP R1 R5
BE 1
B -7
*_____________________________________________________

==========================================================================================================

挿入ソートのための準備
133: MOV R7 R1    //R7 = 1024
LI R3 1   //R3=1:メモリから値を読み出しようのポインタi
LI R4 0      //R4=0: 上と同様の役割の-1バージョンi-1
_______________________________________________________________________________
*
CMP R3 R7  //挿入ソートの終わり判定
BE 20

97:LD R0 0(R3) //R0=a[i]: R0に比べる値を格納
LD R1 0(R4) //R1=a[i-1]: i-1番目のメモリの値をR1に格納
MOV R2 R0   //R2=R0: tmp=a[i]

100:CMP R1 R2   //ソートが不必要なとき分岐
BLT 12      //if(R1<R2): if(a[i-1]<tmp)

ソートが必要なとき
102:MOV R5 R3   //R5=R3: j=i
MOV R6 R4   //R6=R4: j-1=i-1

  _______________________________________________________________
  *
  ソートが必要となったときにその値をどこに入れるか
  104:ST R1 0(R5) //a[R5] = R1: a[j]=array[j-1]
  ADDI R5 -1  //j=j-1
  ADDI R6 -1  //j-1=j-2
  LD R1 0(R6) //R1=a[j-1]: jを更新(-1)したのちのj-1番目のメモリの値をR1に格納
  CMPI R5 0   //if(j=0)分岐
  BE 3        //ほぼj!=0だから条件不成立でそのまま成立のときだけ分岐j=0で次のiへ
  CMP  R1 R2  //ソートが必要なときループに戻る、不必要なとき先に分岐
  BLT 1
  B -9        //R1>R2のときつまりarray[j-1]>tmpのときループに戻る
  *______________________________________________________________

113:ST R2 0(R5) //a[R5]=R2: a[j]=tmp

ADDI R3 1   //R3=R3+1: i=i+1
ADDI R4 1   //R4=r4+1: i-1=i

B -22
*_______________________________________________________________________________
116:HLT
